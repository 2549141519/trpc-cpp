// Code generated by protoc trpc plugin. DO NOT EDIT.
// source: {{ .ProtoFileName }}

#pragma once

#include "{{ replaceSuffix .ProtoFileName ".proto" ".pb.h" }}"

#include "trpc/client/rpc_service_proxy.h"
#include "trpc/server/rpc_service_impl.h"

{{- $namespaces := (split .PackageName ".") }}
{{ range $val := $namespaces }}
namespace {{$val}} {
{{- end }}

{{ range $service := .Services -}}
{{ $svcName := $service.Name -}}

class {{ $svcName }} : public ::trpc::RpcServiceImpl {
 public:
  {{ $svcName }}();

  static const ::google::protobuf::ServiceDescriptor* GetServiceDescriptor();

  {{- range $service.RPCs -}}
  {{- $rpcReqType := .RequestType -}}
	{{- $rpcRspType := .ResponseType -}}
  {{- $methodName := .Name -}}

  {{- if and .ClientStreaming (not .ServerStreaming) }}{{/*ClientStreaming*/}}
  virtual ::trpc::Status {{ $methodName }}(const ::trpc::ServerContextPtr& context, const ::trpc::stream::StreamReader<{{ $rpcReqType }}>& reader, {{ $rpcRspType }}* response);
  {{- else if and .ServerStreaming (not .ClientStreaming) }}{{/*ServerStreaming*/}}
  virtual ::trpc::Status {{ $methodName }}(const ::trpc::ServerContextPtr& context, const {{ $rpcReqType }}& request, ::trpc::stream::StreamWriter<{{ $rpcRspType }}>* writer);
  {{- else if and .ServerStreaming .ClientStreaming }}{{/*BidiStreaming*/}}
  virtual ::trpc::Status {{ $methodName }}(const ::trpc::ServerContextPtr& context, const ::trpc::stream::StreamReader<{{ $rpcReqType }}>& reader, ::trpc::stream::StreamWriter<{{ $rpcRspType }}>* writer);
  {{- else }}{{/*Unary request*/}}
  virtual ::trpc::Status {{ $methodName }}(::trpc::ServerContextPtr context, const {{ $rpcReqType }}* request, {{ $rpcRspType }}* response);
  {{- end -}}{{/* end of if streaming */}}

  {{- end -}}{{/* end of $service.RPCs range */}}
};

class Async{{ $svcName }} : public ::trpc::RpcServiceImpl {
 public:
  Async{{ $svcName }}();

  static const ::google::protobuf::ServiceDescriptor* GetServiceDescriptor();

  {{- range $service.RPCs -}}
  {{- $rpcReqType := .RequestType -}}
	{{- $rpcRspType := .ResponseType -}}
  {{- $methodName := .Name -}}

  {{- if and .ClientStreaming (not .ServerStreaming) }}{{/*ClientStreaming*/}}
  virtual ::trpc::Future<{{ $rpcRspType }}> {{ $methodName }}(const ::trpc::ServerContextPtr& context, const ::trpc::stream::AsyncReaderPtr<{{ $rpcReqType }}>& reader);
  {{- else if and .ServerStreaming (not .ClientStreaming) }}{{/*ServerStreaming*/}}
  virtual ::trpc::Future<> {{ $methodName }}(const ::trpc::ServerContextPtr& context, {{ $rpcReqType }}&& request, const ::trpc::stream::AsyncWriterPtr<{{ $rpcRspType }}>& writer);
  {{- else if and .ServerStreaming .ClientStreaming }}{{/*BidiStreaming*/}}
  virtual ::trpc::Future<> {{ $methodName }}(const ::trpc::ServerContextPtr& context, const ::trpc::stream::AsyncReaderWriterPtr<{{ $rpcReqType }}, {{ $rpcRspType }}>& rw);
  {{- else }}{{/*Unary request*/}}
  virtual ::trpc::Future<{{ $rpcRspType }}> {{ $methodName }}(const ::trpc::ServerContextPtr& context, const {{ $rpcReqType }}* request);
  {{- end -}}{{/* end of if streaming */}}

  {{- end -}}{{/* end of $service.RPCs range */}}  
};

class {{ $svcName }}ServiceProxy : public ::trpc::RpcServiceProxy {
 public:
  {{- range $service.RPCs -}}
  {{- $rpcReqType := .RequestType -}}
	{{- $rpcRspType := .ResponseType -}}
  {{- $methodName := .Name }}

  {{- if and .ClientStreaming (not .ServerStreaming) }}{{/*ClientStreaming*/}}
  virtual ::trpc::stream::StreamWriter<{{ $rpcReqType }}> {{ $methodName }}(const ::trpc::ClientContextPtr& context, {{ $rpcRspType }}* response);
  {{- else if and .ServerStreaming (not .ClientStreaming) }}{{/*ServerStreaming*/}}
  virtual ::trpc::stream::StreamReader<{{ $rpcRspType }}> {{ $methodName }}(const ::trpc::ClientContextPtr& context, const {{ $rpcReqType }}& request);
  {{- else if and .ServerStreaming .ClientStreaming }}{{/*BidiStreaming*/}}
  virtual ::trpc::stream::StreamReaderWriter<{{ $rpcReqType }}, {{ $rpcRspType }}> {{ $methodName }}(const ::trpc::ClientContextPtr& context);
  {{- else }}{{/*Unary request*/}}
  virtual ::trpc::Status {{ $methodName }}(const ::trpc::ClientContextPtr& context, const {{ $rpcReqType }}& request, {{ $rpcRspType }}* response);
  virtual ::trpc::Future<{{ $rpcRspType }}> Async{{ $methodName }}(const ::trpc::ClientContextPtr& context, const {{ $rpcReqType }}& request);
  virtual ::trpc::Status {{ $methodName }}(const ::trpc::ClientContextPtr& context, const {{ $rpcReqType }}& request);
  {{- end -}}{{/* end of if streaming */}}

  {{- end -}}{{/* end of $service.RPCs range */}}
};

class Async{{ $svcName }}ServiceProxy : public ::trpc::RpcServiceProxy {
 public:
  {{- range $service.RPCs -}}
  {{- $rpcReqType := .RequestType -}}
	{{- $rpcRspType := .ResponseType -}}
  {{- $methodName := .Name }}

  {{- if and .ClientStreaming (not .ServerStreaming) }}{{/*ClientStreaming*/}}
  ::trpc::Future<std::pair<::trpc::stream::AsyncWriterPtr<{{ $rpcReqType }}>, ::trpc::Future<{{ $rpcRspType }}>>> {{ $methodName }}(const ::trpc::ClientContextPtr& context);
  {{- else if and .ServerStreaming (not .ClientStreaming) }}{{/*ServerStreaming*/}}
  ::trpc::Future<::trpc::stream::AsyncReaderPtr<{{ $rpcRspType }}>> {{ $methodName }}(const ::trpc::ClientContextPtr& context, {{ $rpcReqType }}&& request);
  {{- else if and .ServerStreaming .ClientStreaming }}{{/*BidiStreaming*/}}
  ::trpc::Future<::trpc::stream::AsyncReaderWriterPtr<{{ $rpcRspType }}, {{ $rpcReqType }}>> {{ $methodName }}(const ::trpc::ClientContextPtr& context);
  {{- else }}{{/*Unary request*/}}
  ::trpc::Future<{{ $rpcRspType }}> {{ $methodName }}(const ::trpc::ClientContextPtr& context, const {{ $rpcReqType }}& request);
  // TODO: one-way  
  {{- end -}}{{/* end of if streaming */}}

  {{- end -}}{{/* end of $service.RPCs range */}}
};

{{- end -}}{{/* end of services range */}}

{{ range $val := (reverseStringSlice $namespaces)  }}
} // end namespace {{ $val }}
{{- end }}
